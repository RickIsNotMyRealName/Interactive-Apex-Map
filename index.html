<!-- map.html -->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Map Visualizer + Drawing Tools</title>
  <link rel="stylesheet" href="styles.css">

  <!-- Fabric.js for drawing overlay -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
</head>

<body>
  <div id="container">
    <div id="sidebar">
      <h1>Map Visualizer</h1>

      <!-- â”€â”€ DATA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
      <details open>
        <summary>Data</summary>
        <label>Choose a built-in map:
          <select id="defaultMapSelect">
            <option value="">â€“ Select â€“</option>
          </select>
        </label>
        <div id="customJsonContainer" style="display:none;">
          <small style="display:block;margin:4px 0;">
            â€¦or load your own JSON:
          </small>
          <label>Custom JSON:
            <input type="file" id="combinedInput" accept=".json">
          </label>
        </div>
      </details>

      <!-- â”€â”€ ENTITY-TYPE CONFIG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
      <details open>
        <summary>Entity Types Config</summary>
        <label>Default from <code>entityTypes/entity-types.json</code></label>
        <label>Override Config:
          <input type="file" id="etConfigInput" accept=".json">
        </label>
      </details>

      <!-- â”€â”€ ENTITY-TYPE TOGGLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
      <details open>
        <summary>Entity Types</summary>
        <div id="entityTypes"></div>
      </details>

      <!-- â”€â”€ PROPERTY FILTERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
      <details>
        <summary>Filters</summary>
        <div id="filters"></div>
      </details>

      <!-- â”€â”€ FILE LEGEND â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
      <details>
        <summary>Legend</summary>
        <div id="legend"></div>
      </details>

      <!-- â”€â”€ HEIGHT COLOURING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
      <details open>
        <summary>Height Colouring</summary>
        <label>Min&nbsp;H:
          <input type="number" id="heightMinInput">
        </label>
        <label>Max&nbsp;H:
          <input type="number" id="heightMaxInput">
        </label>
        <label><input type="checkbox" id="hideOutCB"> Hide out-of-range</label>
        <small>&lt; min â†’ cyan,&nbsp;&gt; max â†’ magenta</small>
        <div id="heightLegend"></div>
      </details>
    </div>

    <div id="main">

      <!-- DRAWING TOOLBAR -->
      <div id="toolbar">
        <button id="selectBtn">Select</button>
        <button id="rectBtn">Rectangle</button>
        <button id="circleBtn">Circle</button>
        <button id="ellipseBtn">Ellipse</button>
        <button id="pencilBtn">Freehand</button>
        <button id="textBtn">Text</button>
        <button id="arrowBtn">Arrow</button>
        <label>
          Image: <input type="file" id="imageInput" accept="image/*">
        </label>
        <button id="groupBtn">Group</button>
        <button id="ungroupBtn">Ungroup</button>
        <button id="bringForwardBtn">Bring Forward</button>
        <button id="sendBackwardBtn">Send Back</button>

        <!-- new delete tool -->
        <button id="deleteBtn">ğŸ—‘ï¸ Delete</button>
      </div>


      <!-- STACKED CANVASES -->
      <div id="canvasContainer">
        <canvas id="mapCanvas"></canvas>
        <canvas id="drawingCanvas"></canvas>
      </div>

      <div id="tooltip"></div>
    </div>
  </div>

  <script>
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 1) DOM SHORTCUTS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const $ = id => document.getElementById(id);
    const defaultMapSelect = $('defaultMapSelect');
    const customJsonContainer = $('customJsonContainer');
    const combinedInput = $('combinedInput');
    const etConfigInput = $('etConfigInput');
    const entityTypesDiv = $('entityTypes');
    const filtersDiv = $('filters');
    const legendDiv = $('legend');
    const mapCanvas = $('mapCanvas');
    const ctx = mapCanvas.getContext('2d');
    const drawingCanvas = $('drawingCanvas');
    const tooltip = $('tooltip');
    const heightMinInput = $('heightMinInput');
    const heightMaxInput = $('heightMaxInput');
    const hideOutCB = $('hideOutCB');
    const heightLegend = $('heightLegend');

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 2) GLOBAL STATE
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const propertyKeys = ['model', 'editorclass', 'classname', 'environment', 'instance_name', 'script_name'];
    let filters = {}, missingFilters = {};
    let mapDef = null, mapImage = null, worldBounds = {};
    let entData = [];
    let entityTypeConfig = [], entityTypeFilters = [];
    const iconCache = {};   // raw <img>
    const tintedIconCache = {};   // offscreen tinted
    const transform = { scale: 1, offsetX: 0, offsetY: 0 };
    let isDragging = false, dragStart = { x: 0, y: 0 }, needsRedraw = false, zipSegments = [];
    let heightMin = 0, heightMax = 0, hideOutOfRange = false;
    const belowClr = '#00ffff', aboveClr = '#ff00ff';

    // initialize Fabric.js overlay
    const fabricCanvas = new fabric.Canvas('drawingCanvas', {
      selection: true,
      preserveObjectStacking: true
    });

    attachMapPan(fabricCanvas.upperCanvasEl);

    function getViewportCenter() {
      const w = fabricCanvas.getWidth();
      const h = fabricCanvas.getHeight();
      return {
        x: (w / 2 - transform.offsetX) / transform.scale,
        y: (h / 2 - transform.offsetY) / transform.scale,
      };
    }

    fabricCanvas.on('path:created', opt => {
      // 1) exit pencil mode
      fabricCanvas.isDrawingMode = false;
      // (optional) re-enable selection if youâ€™d like:
      fabricCanvas.selection = true;
      fabricCanvas.forEachObject(o => o.selectable = true);

      // 2) deselect the new path so it isnâ€™t active
      fabricCanvas.discardActiveObject();

      // 3) re-render
      fabricCanvas.requestRenderAll();
    });


    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 3) TINT HELPER
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function createTintedIcon(img, tintColor) {
      const w = img.naturalWidth, h = img.naturalHeight;
      const off = document.createElement('canvas');
      off.width = w; off.height = h;
      const octx = off.getContext('2d');
      octx.drawImage(img, 0, 0, w, h);
      octx.globalCompositeOperation = 'screen';
      octx.fillStyle = tintColor;
      octx.fillRect(0, 0, w, h);
      octx.globalCompositeOperation = 'destination-in';
      octx.drawImage(img, 0, 0, w, h);
      octx.globalCompositeOperation = 'source-over';
      return off;
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 4) LOAD DEFAULT MAP LIST
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    async function loadDefaultList() {
      try {
        const res = await fetch('./maps/manifest.json');
        if (!res.ok) throw new Error(res.statusText);
        const list = await res.json();
        list.forEach(({ name, file }) => {
          const opt = document.createElement('option');
          opt.value = `./maps/${file}`;
          opt.textContent = name;
          defaultMapSelect.appendChild(opt);
        });
        const customOpt = document.createElement('option');
        customOpt.value = '__custom';
        customOpt.textContent = 'Load custom JSONâ€¦';
        defaultMapSelect.appendChild(customOpt);
      } catch (err) {
        console.warn('Could not load map manifest:', err);
      }
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 5) LOAD ENTITY-TYPES (with tint-cache)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    async function loadDefaultEntityTypes() {
      try {
        const res = await fetch('./entityTypes/entity-types.json');
        if (!res.ok) throw new Error(res.statusText);
        const list = await res.json();
        entityTypeConfig = list;
        entityTypeFilters = list.map(() => false);
        // clear caches
        for (const k in iconCache) delete iconCache[k];
        for (const k in tintedIconCache) delete tintedIconCache[k];
        // load icons & tinted versions
        list.forEach((c, i) => {
          if (c.renderType === 'icon' && c.icon) {
            const img = new Image();
            img.src = c.icon;
            iconCache[i] = img;
            img.onload = () => {
              if (c.tintColor) {
                tintedIconCache[i] = createTintedIcon(img, c.tintColor);
                scheduleDraw();
              }
            };
          }
        });
        buildEntityTypes();
      } catch (err) {
        console.warn('Could not load entity types:', err);
      }
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 6) HANDLE LOADED MAP+ENTITIES
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function handleCombinedData(data, sourceName) {
      // background
      mapImage = new Image();
      mapImage.onload = () => {
        transform.scale = 1;
        transform.offsetX = transform.offsetY = 0;
        resizeCanvases();
      };
      mapImage.src = 'data:image/png;base64,' + data.background_image;

      // mapDef
      const cfg = data.config;
      mapDef = { posX: +cfg.pos_x, posY: +cfg.pos_y, scale: +cfg.scale };

      // entities
      const raw = Array.isArray(data.entities) ? data.entities : [];
      let mn = Infinity, mx = -Infinity;
      const ents = raw.filter(e => typeof e.origin === 'string').map(e => {
        const props = { ...e };
        const [x, y, z = 0] = props.origin.split(/\s+/).map(Number);
        props.x = x; props.y = y; props.height = z;
        mn = Math.min(mn, z);
        mx = Math.max(mx, z);
        return { x, y, h: z, props };
      });
      heightMin = Math.floor(mn);
      heightMax = Math.ceil(mx);
      heightMinInput.value = heightMin;
      heightMaxInput.value = heightMax;
      rebuildHeightLegend();

      entData = [{ ents, color: '#e6194b', fileName: sourceName, enabled: true }];
      buildLegend();
      buildFilters();
      buildZipCache();
      scheduleDraw();
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 7) EVENT HANDLERS: mapSelect, file inputs
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    defaultMapSelect.addEventListener('change', async e => {
      const v = e.target.value;
      if (v === '__custom') {
        customJsonContainer.style.display = 'block';
        return;
      } else {
        customJsonContainer.style.display = 'none';
      }
      if (!v) return;
      try {
        const txt = await fetch(v).then(r => r.ok ? r.text() : Promise.reject(r.status));
        handleCombinedData(JSON.parse(txt), v.split('/').pop());
      } catch (err) {
        alert('Could not load map: ' + err);
      }
    });
    combinedInput.addEventListener('change', e => {
      const f = e.target.files[0];
      if (!f) return;
      const r = new FileReader();
      r.onload = () => { try { handleCombinedData(JSON.parse(r.result), f.name); } catch (e) { alert('Invalid JSON:' + e); } };
      r.readAsText(f);
    });
    etConfigInput.addEventListener('click', () => etConfigInput.value = '');
    etConfigInput.addEventListener('change', e => {
      const f = e.target.files[0];
      if (!f) return;
      const r = new FileReader();
      r.onload = () => {
        try {
          entityTypeConfig = JSON.parse(r.result);
          entityTypeFilters = entityTypeConfig.map(() => false);
          for (const k in iconCache) delete iconCache[k];
          for (const k in tintedIconCache) delete tintedIconCache[k];
          entityTypeConfig.forEach((c, i) => {
            if (c.renderType === 'icon' && c.icon) {
              const img = new Image();
              img.src = c.icon;
              iconCache[i] = img;
              img.onload = () => {
                if (c.tintColor) tintedIconCache[i] = createTintedIcon(img, c.tintColor);
                scheduleDraw();
              };
            }
          });
          buildEntityTypes();
          scheduleDraw();
        } catch (err) {
          alert('Invalid JSON:' + err);
        }
      };
      r.readAsText(f);
    });

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 8) BUILD UI PANELS (entityTypes, legend, filters, zip)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function buildEntityTypes() {
      entityTypesDiv.innerHTML = '';
      entityTypeConfig.forEach((c, i) => {
        const lbl = document.createElement('label');
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.onchange = () => { entityTypeFilters[i] = cb.checked; scheduleDraw(); };
        lbl.append(cb, ' ', c.nickname);
        entityTypesDiv.append(lbl);
      });
    }

    function buildLegend() {
      legendDiv.innerHTML = '';
      entData.forEach(item => {
        const lbl = document.createElement('label');
        const cb = document.createElement('input');
        cb.type = 'checkbox'; cb.checked = item.enabled;
        cb.onchange = () => { item.enabled = cb.checked; scheduleDraw(); };
        const sw = document.createElement('span');
        sw.style.cssText = 'width:14px;height:14px;display:inline-block;margin-right:8px;' +
          'border:1px solid #999;background:' + item.color;
        lbl.append(cb, sw, item.fileName);
        legendDiv.append(lbl);
      });
    }

    function buildFilters() {
      filters = {}; missingFilters = {};
      propertyKeys.forEach(k => { filters[k] = new Set(); missingFilters[k] = false; });
      entData.forEach(d => d.ents.forEach(e => {
        propertyKeys.forEach(k => { if (e.props[k]) filters[k].add(e.props[k]); });
      }));
      filtersDiv.innerHTML = '';
      propertyKeys.forEach(key => {
        const fg = document.createElement('div');
        fg.className = 'filter-group';
        fg.append(Object.assign(document.createElement('strong'), { textContent: key }));
        // all checkbox
        const allCB = document.createElement('input');
        allCB.type = 'checkbox';
        const allLbl = document.createElement('label');
        allLbl.append(allCB, ' All');
        allCB.onchange = () => {
          fg.querySelectorAll('input[data-val]').forEach(ch => {
            ch.checked = allCB.checked;
            ch.checked ? filters[key].add(ch.dataset.val) : filters[key].delete(ch.dataset.val);
          });
          scheduleDraw();
        };
        fg.append(allLbl);
        // missing checkbox
        const missCB = document.createElement('input');
        missCB.type = 'checkbox';
        const missLbl = document.createElement('label');
        missLbl.append(missCB, ' Missing');
        missCB.onchange = () => { missingFilters[key] = missCB.checked; scheduleDraw(); };
        fg.append(missLbl);
        // search
        const search = document.createElement('input');
        search.type = 'text';
        search.placeholder = `Search ${key}`;
        search.oninput = () => {
          const t = search.value.toLowerCase();
          fg.querySelectorAll('label[data-val]').forEach(l => {
            l.style.display = l.textContent.toLowerCase().includes(t) ? 'block' : 'none';
          });
        };
        fg.append(search);
        // each value
        [...filters[key]].sort().forEach(v => {
          const lbl = document.createElement('label');
          lbl.dataset.val = v;
          const cb = document.createElement('input');
          cb.type = 'checkbox'; cb.dataset.val = v;
          cb.onchange = () => { cb.checked ? filters[key].add(v) : filters[key].delete(v); scheduleDraw(); };
          lbl.append(cb, ' ', v);
          fg.append(lbl);
        });
        filtersDiv.append(fg);
      });
    }

    function buildZipCache() {
      zipSegments = []; const tmp = {};
      entData.forEach(d => d.ents.forEach(e => {
        if (e.props.classname === 'zipline') tmp[e.props.link_guid] = { start: e, end: null };
      }));
      entData.forEach(d => d.ents.forEach(e => {
        if (e.props.classname === 'zipline_end' && tmp[e.props.link_guid])
          tmp[e.props.link_guid].end = e;
      }));
      Object.values(tmp).forEach(z => {
        if (!z.start) return;
        const seg = [{ x: z.start.x, y: z.start.y }];
        Object.entries(z.start.props).forEach(([k, v]) => {
          const m = k.match(/_zipline_rest_point_(\d+)/);
          if (m) {
            const [rx, ry] = v.split(/\s+/).map(Number);
            seg.push({ idx: +m[1], x: rx, y: ry });
          }
        });
        seg.sort((a, b) => a.idx - b.idx);
        if (z.end) seg.push({ x: z.end.x, y: z.end.y });
        if (seg.length > 1) zipSegments.push(seg);
      });
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 9) HEIGHT LEGEND
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function rebuildHeightLegend() {
      const grad = `linear-gradient(to right,
      ${belowClr} 0%,
      ${heightToColour(heightMin)} 0%,
      ${heightToColour(heightMax)} 100%,
      ${aboveClr} 100%)`;
      heightLegend.innerHTML = '';
      const bar = document.createElement('div');
      bar.style.cssText = 'height:18px;background:' + grad + ';border:1px solid #555;margin-bottom:4px';
      heightLegend.append(bar);
      const lbl = document.createElement('div');
      lbl.style.cssText = 'display:flex;justify-content:space-between;font-size:0.75em;color:#aaa';
      lbl.innerHTML = `<span>&lt;${heightMin}</span><span>${heightMin}</span>
                   <span>${heightMax}</span><span>&gt;${heightMax}</span>`;
      heightLegend.append(lbl);
    }

    function heightToColour(h) {
      if (h < heightMin) return belowClr;
      if (h > heightMax) return aboveClr;
      const t = (h - heightMin) / (heightMax - heightMin);
      const hue = 240 * (1 - t);
      return `hsl(${hue},100%,50%)`;
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 10) DRAW ALL (map + entities + tinted icons)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function scheduleDraw() {
      if (!needsRedraw) {
        needsRedraw = true;
        requestAnimationFrame(() => {
          needsRedraw = false;
          drawAll();
        });
      }
    }

    function worldToCanvas(x, y) {
      const px = (x - worldBounds.minX) / (worldBounds.maxX - worldBounds.minX) * mapCanvas.width;
      const py = (y - worldBounds.minY) / (worldBounds.maxY - worldBounds.minY) * mapCanvas.height;
      return { cx: px, cy: mapCanvas.height - py };
    }

    function resizeCanvases() {
      if (!mapImage) return;
      const rect = mapCanvas.parentElement.getBoundingClientRect();
      const w = rect.width;
      const h = rect.width * (mapImage.naturalHeight / mapImage.naturalWidth);

      // â‘  resize your two HTML canvases
      mapCanvas.width = w;
      mapCanvas.height = h;
      drawingCanvas.width = w;
      drawingCanvas.height = h;

      // â‘¡ tell Fabric the new size
      fabricCanvas.setWidth(w);
      fabricCanvas.setHeight(h);

      // â‘¢ IMPORTANT: recalc Fabricâ€™s pointer offsets & render
      fabricCanvas.calcOffset();
      fabricCanvas.requestRenderAll();

      scheduleDraw();
    }

    window.addEventListener('resize', resizeCanvases);

    function drawAll() {
      if (!mapImage || !mapDef) return;

      // recompute worldBounds
      const { posX, posY, scale } = mapDef;
      worldBounds = {
        minX: posX,
        maxX: posX + mapImage.naturalWidth * scale,
        minY: posY - mapImage.naturalHeight * scale,
        maxY: posY
      };

      // draw base map
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);
      ctx.translate(transform.offsetX, transform.offsetY);
      ctx.scale(transform.scale, transform.scale);
      ctx.drawImage(mapImage, 0, 0, mapCanvas.width, mapCanvas.height);

      // draw heightâ€coloured dots
      entData.forEach(item => {
        if (!item.enabled) return;
        item.ents.forEach(e => {
          if (entityIsSkipped(e)) return;
          if (hideOutOfRange && (e.h < heightMin || e.h > heightMax)) return;
          const { cx, cy } = worldToCanvas(e.x, e.y);
          ctx.fillStyle = heightToColour(e.h);
          ctx.beginPath(); ctx.arc(cx, cy, 5 / transform.scale, 0, 2 * Math.PI); ctx.fill();
        });
      });

      // draw ziplines
      const zipIdx = entityTypeConfig.findIndex(c => c.renderType === 'zipline');
      if (zipIdx > -1 && entityTypeFilters[zipIdx]) {
        const cfg = entityTypeConfig[zipIdx];
        ctx.strokeStyle = cfg.color || 'orange';
        ctx.lineWidth = (cfg.lineWidth || 2) / transform.scale;
        zipSegments.forEach(seg => {
          ctx.beginPath();
          seg.forEach((p, i) => {
            const { cx, cy } = worldToCanvas(p.x, p.y);
            i ? ctx.lineTo(cx, cy) : ctx.moveTo(cx, cy);
          });
          ctx.stroke();
        });
      }

      // draw other entityâ€types (including tinted icons)
      entityTypeConfig.forEach((c, i) => {
        if (i === zipIdx || !entityTypeFilters[i]) return;
        entData.forEach(item => {
          if (!item.enabled) return;
          item.ents.forEach(e => {
            let pv = e.props[c.field] || '';
            if (c.valueRegex) {
              if (!new RegExp(c.valueRegex).test(pv)) return;
            } else if (c.value !== undefined) {
              if (pv !== c.value) return;
            }
            const { cx, cy } = worldToCanvas(e.x, e.y);
            const sx = cx * transform.scale + transform.offsetX;
            const sy = cy * transform.scale + transform.offsetY;

            // ICON with tint
            if (c.renderType === 'icon' && iconCache[i] && iconCache[i].complete) {
              const sz = c.size || 24;
              ctx.setTransform(1, 0, 0, 1, 0, 0);
              const src = (c.tintColor && tintedIconCache[i])
                ? tintedIconCache[i]
                : iconCache[i];
              ctx.drawImage(src, sx - sz / 2, sy - sz / 2, sz, sz);

              // CIRCLE
            } else if (c.renderType === 'circle') {
              const rW = c.radiusField
                ? parseFloat(e.props[c.radiusField] || 0)
                : parseFloat(c.radius || 0);
              if (!rW) return;
              const basePx = (rW / (worldBounds.maxX - worldBounds.minX)) * mapCanvas.width;
              const rpx = basePx * transform.scale;
              ctx.setTransform(1, 0, 0, 1, 0, 0);
              ctx.fillStyle = c.fillColor || 'rgba(255,0,0,0.25)';
              ctx.strokeStyle = c.strokeColor || '#ff4444';
              ctx.lineWidth = (c.strokeWidth || 2) / transform.scale;
              ctx.beginPath(); ctx.arc(sx, sy, rpx, 0, 2 * Math.PI);
              ctx.fill(); ctx.stroke();

              // DOT
            } else if (c.renderType === 'dot') {
              const or = c.outerRadius || 8, ir = c.innerRadius || 4;
              ctx.setTransform(1, 0, 0, 1, 0, 0);
              ctx.fillStyle = c.outerColor || 'lime';
              ctx.beginPath(); ctx.arc(sx, sy, or, 0, 2 * Math.PI); ctx.fill();
              if (c.innerColor) {
                ctx.fillStyle = c.innerColor;
                ctx.beginPath(); ctx.arc(sx, sy, ir, 0, 2 * Math.PI); ctx.fill();
              }

              // TEXT
            } else if (c.renderType === 'text') {
              let txt = c.textField
                ? (e.props[c.textField] || '')
                : (c.text || '');
              if (!txt) return;
              if (c.regexFind) txt = txt.replace(new RegExp(c.regexFind, 'g'), c.regexReplace || '');
              if (c.replaceUnderscores) txt = txt.replace(/_/g, ' ');
              if (c.case === 'upper') txt = txt.toUpperCase();
              else if (c.case === 'lower') txt = txt.toLowerCase();
              else if (c.case === 'title') txt = txt.replace(/\w\S*/g, w => w[0].toUpperCase() + w.slice(1));

              ctx.setTransform(1, 0, 0, 1, 0, 0);
              const base = c.fontSize || 14;
              const fs = c.scaleWithZoom ? base * transform.scale : base;
              ctx.font = `${fs}px ${c.fontFamily || 'Arial'}`;
              ctx.fillStyle = c.textColor || '#fff';
              ctx.textAlign = c.textAlign || 'center';
              ctx.textBaseline = c.textBaseline || 'middle';
              ctx.fillText(txt, sx + (c.offsetX || 0), sy + (c.offsetY || 0));
            }
          });
        });
      });
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 11) TOOLTIP
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    mapCanvas.addEventListener('mousemove', e => {
      const mx = e.offsetX, my = e.offsetY;
      const cX = (mx - transform.offsetX) / transform.scale;
      const cY = (my - transform.offsetY) / transform.scale;
      let found = null, r = 5 / transform.scale;
      outer: for (const item of entData) {
        if (!item.enabled) continue;
        for (const ent of item.ents) {
          if (entityIsSkipped(ent)) continue;
          if (hideOutOfRange && (ent.h < heightMin || ent.h > heightMax)) continue;
          const { cx, cy } = worldToCanvas(ent.x, ent.y);
          if ((cX - cx) ** 2 + (cY - cy) ** 2 < r * r) {
            found = ent; break outer;
          }
        }
      }
      if (found) {
        tooltip.style.display = 'block';
        tooltip.style.left = (mx + 10) + 'px';
        tooltip.style.top = (my + 10) + 'px';
        tooltip.innerHTML = Object.entries(found.props)
          .map(([k, v]) => `<strong>${k}</strong>: ${typeof v === 'object' ? JSON.stringify(v) : v}`)
          .join('<br>');
      } else {
        tooltip.style.display = 'none';
      }
    });

    function attachMapPan(el) {
      let isDragging = false;

      // â”€â”€ ZOOM â”€â”€
      el.addEventListener('wheel', e => {
        if (fabricCanvas.isDrawingMode) return;         // â† skip when drawing
        e.preventDefault();
        const factor = e.deltaY < 0 ? 1.1 : 0.9;
        const zoom = fabricCanvas.getZoom() * factor;
        fabricCanvas.zoomToPoint(
          new fabric.Point(e.offsetX, e.offsetY),
          zoom
        );
        syncTransform();
        scheduleDraw();
      }, { passive: false });

      // â”€â”€ START PAN â”€â”€
      el.addEventListener('mousedown', e => {
        if (fabricCanvas.isDrawingMode) return;         // â† skip when drawing
        if (fabricCanvas.findTarget(e)) return;         // â† skip when clicking a shape
        isDragging = true;
        el.style.cursor = 'grabbing';
      });

      // â”€â”€ PAN â”€â”€
      el.addEventListener('mousemove', e => {
        if (fabricCanvas.isDrawingMode || !isDragging) return;  // â† skip when drawing
        fabricCanvas.relativePan(
          new fabric.Point(e.movementX, e.movementY)
        );
        syncTransform();
        scheduleDraw();
      });

      // â”€â”€ END PAN â”€â”€
      ['mouseup', 'mouseleave'].forEach(evt =>
        el.addEventListener(evt, () => {
          isDragging = false;
          el.style.cursor = 'grab';
        })
      );
    }

    // helper to sync your transform object from Fabricâ€™s viewport
    function syncTransform() {
      const vpt = fabricCanvas.viewportTransform;
      transform.scale = vpt[0];
      transform.offsetX = vpt[4];
      transform.offsetY = vpt[5];
    }


    // â”€â”€â”€â”€ DRAWING TOOLBAR HANDLERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    /**
     * Returns the true center of the _visible_ canvas in world-coords,
     * by:
     *  1) grabbing the on-screen client size,
     *  2) inverting the current viewport matrix,
     *  3) mapping the screen center back into world space.
     */
    function getViewportCenter() {
      // â‘  ensure Fabric knows the true DOM offsets
      fabricCanvas.calcOffset();

      // â‘¡ measure the upperâ€canvas on screen
      const rect = fabricCanvas.upperCanvasEl.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;

      // â‘¢ ask Fabric: â€œwhere in worldâ€space is this clientâ€point?â€
      const pt = fabricCanvas.getPointer({ clientX: centerX, clientY: centerY });
      return pt;  // { x:â€¦, y:â€¦ } in world coords
    }

    function activateTool(btnId) {
      document.querySelectorAll('#toolbar button').forEach(b => b.classList.remove('active'));
      $(btnId).classList.add('active');
    }


    // switch to selection
    $('selectBtn').onclick = () => {
      activateTool('selectBtn');
      fabricCanvas.isDrawingMode = false;
      fabricCanvas.selection = true;
      fabricCanvas.forEachObject(o => o.selectable = true);
    };

    // rectangle
    $('rectBtn').onclick = () => {
      activateTool('rectBtn');
      fabricCanvas.isDrawingMode = false;
      const { x, y } = getViewportCenter();
      const r = new fabric.Rect({
        left: x, top: y,
        width: 100, height: 60,
        originX: 'center', originY: 'center',
        fill: 'rgba(0,0,0,0)', stroke: '#000', strokeWidth: 2
      });
      fabricCanvas.add(r).setActiveObject(r);
      fabricCanvas.discardActiveObject();  // â† unselect
      fabricCanvas.requestRenderAll();
    };

    // circle
    $('circleBtn').onclick = () => {
      activateTool('circleBtn');
      fabricCanvas.isDrawingMode = false;
      const { x, y } = getViewportCenter();
      const c = new fabric.Circle({
        left: x, top: y,
        originX: 'center', originY: 'center',
        radius: 40,
        fill: 'rgba(0,0,0,0)', stroke: '#000', strokeWidth: 2
      });
      fabricCanvas.add(c).setActiveObject(c);
      fabricCanvas.discardActiveObject();  // â† unselect
      fabricCanvas.requestRenderAll();
    };

    // ellipse
    $('ellipseBtn').onclick = () => {
      activateTool('ellipseBtn');
      fabricCanvas.isDrawingMode = false;
      const { x, y } = getViewportCenter();
      const e = new fabric.Ellipse({
        left: x, top: y,
        originX: 'center', originY: 'center',
        rx: 60, ry: 30,
        fill: 'rgba(0,0,0,0)', stroke: '#000', strokeWidth: 2
      });
      fabricCanvas.add(e).setActiveObject(e);
      fabricCanvas.discardActiveObject();  // â† unselect
      fabricCanvas.requestRenderAll();
    };

    // freehand
    $('pencilBtn').onclick = () => {
      activateTool('pencilBtn');
      fabricCanvas.isDrawingMode = true;
      fabricCanvas.freeDrawingBrush.width = 2;
      fabricCanvas.freeDrawingBrush.color = '#000';
      fabricCanvas.freeDrawingCursor = 'crosshair';   // â† nicer cursor
    };

    // text
    $('textBtn').onclick = () => {
      activateTool('textBtn');
      fabricCanvas.isDrawingMode = false;
      const { x, y } = getViewportCenter();
      const t = new fabric.IText('Edit me', {
        left: x, top: y,
        originX: 'center', originY: 'center',
        fontSize: 20, fill: '#000'
      });
      fabricCanvas.add(t).setActiveObject(t);
      fabricCanvas.discardActiveObject();  // â† unselect
      fabricCanvas.requestRenderAll();
    };

    // arrow
    $('arrowBtn').onclick = () => {
      activateTool('arrowBtn');
      fabricCanvas.isDrawingMode = false;
      const { x, y } = getViewportCenter();

      // a horizontal line + a triangle on its right end
      const line = new fabric.Line([-50, 0, 50, 0], {
        stroke: '#000', strokeWidth: 2,
        originX: 'center', originY: 'center'
      });
      const head = new fabric.Triangle({
        left: 50, top: 0,
        originX: 'center', originY: 'center',
        width: 10, height: 10, angle: 90, fill: '#000'
      });
      const arrow = new fabric.Group([line, head], {
        left: x, top: y,
        originX: 'center', originY: 'center'
      });
      fabricCanvas.add(arrow).setActiveObject(arrow);
      fabricCanvas.discardActiveObject();  // â† unselect
      fabricCanvas.requestRenderAll();
    };

    // image upload
    $('imageInput').addEventListener('change', e => {
      activateTool('imageInput');
      const f = e.target.files[0];
      if (!f) return;
      const reader = new FileReader();
      reader.onload = evt => {
        fabric.Image.fromURL(evt.target.result, img => {
          const { x, y } = getViewportCenter();
          img.set({
            left: x, top: y,
            originX: 'center', originY: 'center',
            scaleX: 0.5, scaleY: 0.5
          });
          fabricCanvas.add(img).setActiveObject(img);
          fabricCanvas.discardActiveObject();  // â† unselect
          fabricCanvas.requestRenderAll();
        });
      };
      reader.readAsDataURL(f);
    });

    // group
    $('groupBtn').onclick = () => {
      activateTool('groupBtn');
      const sel = fabricCanvas.getActiveObjects();
      if (sel.length > 1) {
        const grp = new fabric.Group(sel);
        fabricCanvas.discardActiveObject();
        fabricCanvas.add(grp).setActiveObject(grp);
      }
    };
    // ungroup
    $('ungroupBtn').onclick = () => {
      activateTool('ungroupBtn');
      const obj = fabricCanvas.getActiveObject();
      if (obj && obj.type === 'group') {
        obj.toActiveSelection();
        fabricCanvas.requestRenderAll();
      }
    };
    // z-order
    $('bringForwardBtn').onclick = () => fabricCanvas.getActiveObject()?.bringForward();
    $('sendBackwardBtn').onclick = () => fabricCanvas.getActiveObject()?.sendBackwards();

    // â”€â”€â”€â”€ DELETE TOOL & KEYBINDINGS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    // Delete-button: remove all selected objects
    $('deleteBtn').onclick = () => {
      activateTool('deleteBtn');
      const active = fabricCanvas.getActiveObjects();
      if (active.length) {
        active.forEach(obj => fabricCanvas.remove(obj));
        fabricCanvas.discardActiveObject();
        fabricCanvas.requestRenderAll();
      }
    };

    // Keybindings: Esc = cancel tool / deselect, Del/Backspace = delete selection
    document.addEventListener('keydown', e => {
      // if any text input or other form has focus, ignore
      if (document.activeElement.tagName.match(/INPUT|TEXTAREA/)) return;

      if (e.key === 'Escape') {
        // go back to â€œselectâ€ mode
        fabricCanvas.isDrawingMode = false;
        fabricCanvas.selection = true;
        fabricCanvas.forEachObject(o => o.selectable = true);
        fabricCanvas.discardActiveObject();
        fabricCanvas.requestRenderAll();

        // (optional) visually indicate â€œSelectâ€ in your UI:
        // document.querySelectorAll('#toolbar button').forEach(b=>b.classList.remove('active'));
        // $('selectBtn').classList.add('active');
      }
      else if (e.key === 'Delete' || e.key === 'Backspace') {
        // delete any selected objects
        const active = fabricCanvas.getActiveObjects();
        if (active.length) {
          active.forEach(obj => fabricCanvas.remove(obj));
          fabricCanvas.discardActiveObject();
          fabricCanvas.requestRenderAll();
        }
      }
    });



    // skip filter check
    function entityIsSkipped(e) {
      return propertyKeys.some(k => {
        if (filters[k].size === 0 && !missingFilters[k]) return false;
        const v = e.props[k];
        if (v !== undefined && v !== '') return !filters[k].has(v);
        return !missingFilters[k];
      });
    }

    // kick off
    loadDefaultList();
    loadDefaultEntityTypes();
  </script>
</body>

</html>