<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Map Visualizer</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div id="container">
    <div id="sidebar">
      <h1>Map Visualizer</h1>

      <!-- ── DATA ─────────────────────────────────────────────── -->
      <details open>
        <summary>Data</summary>
        <label>Choose a built-in map:
          <select id="defaultMapSelect">
            <option value="">– Select –</option>
          </select>
        </label>
        <div id="customJsonContainer" style="display:none;">
          <small style="display:block;margin:4px 0;">
            …or load your own JSON:
          </small>
          <label>Custom JSON:
            <input type="file" id="combinedInput" accept=".json">
          </label>
        </div>
      </details>

      <!-- ── ENTITY-TYPE CONFIG ─────────────────────────────────── -->
      <details open>
        <summary>Entity Types Config</summary>
        <label>Default from <code>entityTypes/entity-types.json</code></label>
        <label>Override Config:
          <input type="file" id="etConfigInput" accept=".json">
        </label>
      </details>

      <!-- ── ENTITY-TYPE TOGGLES ──────────────────────────────── -->
      <details open>
        <summary>Entity Types</summary>
        <div id="entityTypes"></div>
      </details>

      <!-- ── PROPERTY FILTERS ─────────────────────────────────── -->
      <details>
        <summary>Filters</summary>
        <div id="filters"></div>
      </details>

      <!-- ── FILE LEGEND ─────────────────────────────────────── -->
      <details>
        <summary>Legend</summary>
        <div id="legend"></div>
      </details>

      <!-- ── HEIGHT COLOURING ─────────────────────────────────── -->
      <details open>
        <summary>Height Colouring</summary>
        <label>Min H:
          <input type="number" id="heightMinInput">
        </label>
        <label>Max H:
          <input type="number" id="heightMaxInput">
        </label>
        <label><input type="checkbox" id="hideOutCB"> Hide out-of-range</label>
        <small>&lt; min → cyan, &gt; max → magenta</small>
        <div id="heightLegend"></div>
      </details>
    </div>

    <div id="main">
      <canvas id="mapCanvas"></canvas>
      <div id="tooltip"></div>
    </div>
  </div>

  <script>
  /* ============================================================= *
   *  DOM SHORTCUTS
   * ============================================================= */
  const $                   = id => document.getElementById(id);
  const defaultMapSelect    = $('defaultMapSelect');
  const customJsonContainer = $('customJsonContainer');
  const combinedInput       = $('combinedInput');
  const etConfigInput       = $('etConfigInput');
  const entityTypesDiv      = $('entityTypes');
  const filtersDiv          = $('filters');
  const legendDiv           = $('legend');
  const canvas              = $('mapCanvas');
  const ctx                 = canvas.getContext('2d');
  const tooltip             = $('tooltip');
  const heightMinInput      = $('heightMinInput');
  const heightMaxInput      = $('heightMaxInput');
  const hideOutCB           = $('hideOutCB');
  const heightLegend        = $('heightLegend');

  /* ============================================================= *
   *  GLOBAL STATE
   * ============================================================= */
  const propertyKeys     = ['model','editorclass','classname','environment','instance_name','script_name'];
  let filters={}, missingFilters={};
  let mapDef=null, mapImage=null, worldBounds={};
  let entData=[];
  let entityTypeConfig=[], entityTypeFilters=[];
  const iconCache       = {};   // raw <img> objects
  const tintedIconCache = {};   // offscreen canvases with tint applied
  const transform       = {scale:1,offsetX:0,offsetY:0};
  let isDragging=false, dragStart={x:0,y:0}, needsRedraw=false, zipSegments=[];
  let heightMin=0, heightMax=0, hideOutOfRange=false;
  const belowClr='#00ffff', aboveClr='#ff00ff';

  /* ============================================================= *
   *  TINT HELPER
   * ============================================================= */
  function createTintedIcon(img, tintColor) {
    const w = img.naturalWidth, h = img.naturalHeight;
    const off = document.createElement('canvas');
    off.width = w; off.height = h;
    const octx = off.getContext('2d');

    // 1) draw original
    octx.drawImage(img, 0, 0, w, h);

    // 2) screen-blend tint
    octx.globalCompositeOperation = 'screen';
    octx.fillStyle = tintColor;
    octx.fillRect(0, 0, w, h);

    // 3) re-apply alpha mask
    octx.globalCompositeOperation = 'destination-in';
    octx.drawImage(img, 0, 0, w, h);

    // 4) restore
    octx.globalCompositeOperation = 'source-over';
    return off;
  }

  /* ============================================================= *
   *  LOAD DEFAULT MAPS
   * ============================================================= */
  async function loadDefaultList() {
    try {
      const res  = await fetch('./maps/manifest.json');
      if (!res.ok) throw new Error(res.statusText);
      const list = await res.json();
      list.forEach(({name,file}) => {
        const opt = document.createElement('option');
        opt.value = `./maps/${file}`;
        opt.textContent = name;
        defaultMapSelect.appendChild(opt);
      });
      const customOpt = document.createElement('option');
      customOpt.value       = '__custom';
      customOpt.textContent = 'Load custom JSON…';
      defaultMapSelect.appendChild(customOpt);
    } catch (err) {
      console.warn('Could not load map manifest:', err);
    }
  }

  /* ============================================================= *
   *  LOAD DEFAULT ENTITY TYPES (with tint)
   * ============================================================= */
  async function loadDefaultEntityTypes() {
    try {
      const res  = await fetch('./entityTypes/entity-types.json');
      if (!res.ok) throw new Error(res.statusText);
      const list = await res.json();

      entityTypeConfig  = list;
      entityTypeFilters = list.map(() => false);

      // clear old caches
      Object.keys(iconCache).forEach(k => delete iconCache[k]);
      Object.keys(tintedIconCache).forEach(k => delete tintedIconCache[k]);

      // load new icons & build tinted variants
      list.forEach((c,i) => {
        if (c.renderType === 'icon' && c.icon) {
          const img = new Image();
          img.src = c.icon;
          iconCache[i] = img;
          img.onload = () => {
            if (c.tintColor) {
              tintedIconCache[i] = createTintedIcon(img, c.tintColor);
              // once tinted is ready, redraw
              scheduleDraw();
            }
          };
        }
      });

      buildEntityTypes();
    } catch(err){
      console.warn('Could not load entity types:', err);
    }
  }

  /* ============================================================= *
   *  SHARED MAP-LOADING PIPELINE
   * ============================================================= */
  function handleCombinedData(data, sourceName) {
    // background
    mapImage = new Image();
    mapImage.onload = ()=>{
      transform.scale = 1;
      transform.offsetX = transform.offsetY = 0;
      resizeCanvas();
    };
    mapImage.src = 'data:image/png;base64,' + data.background_image;

    // map def
    const cfg = data.config;
    mapDef = {
      posX: +cfg.pos_x,
      posY: +cfg.pos_y,
      scale: +cfg.scale
    };

    // entities with heights
    const raw = Array.isArray(data.entities) ? data.entities : [];
    let mn=Infinity, mx=-Infinity;
    const ents = raw.filter(e=>typeof e.origin==='string').map(e => {
      const props = {...e};
      const [x,y,z=0] = props.origin.split(/\s+/).map(Number);
      props.x=x; props.y=y; props.height=z;
      mn = Math.min(mn,z);
      mx = Math.max(mx,z);
      return {x,y,h:z,props};
    });

    // default height limits
    heightMin = Math.floor(mn);
    heightMax = Math.ceil(mx);
    heightMinInput.value = heightMin;
    heightMaxInput.value = heightMax;
    rebuildHeightLegend();

    entData = [{ ents, color:'#e6194b', fileName:sourceName, enabled:true }];
    buildLegend(); buildFilters(); buildZipCache(); scheduleDraw();
  }

  /* ============================================================= *
   *  EVENT HANDLERS (unchanged)
   * ============================================================= */
  defaultMapSelect.addEventListener('change', async e=>{
    const val = e.target.value;
    if(val==='__custom'){
      customJsonContainer.style.display='block';
      return;
    } else {
      customJsonContainer.style.display='none';
    }
    if(!val) return;
    try {
      const txt = await fetch(val).then(r=>r.ok?r.text():Promise.reject(r.status));
      handleCombinedData(JSON.parse(txt), val.split('/').pop());
    } catch(err){
      alert('Could not load map: '+err);
    }
  });

  combinedInput.addEventListener('change', e=>{
    const f=e.target.files[0];
    if(!f) return;
    const r=new FileReader();
    r.onload=()=> {
      try { handleCombinedData(JSON.parse(r.result), f.name); }
      catch(err){ alert('Invalid JSON: '+err); }
    };
    r.readAsText(f);
  });

  etConfigInput.addEventListener('click', ()=>etConfigInput.value='');
  etConfigInput.addEventListener('change', e=>{
    const f=e.target.files[0];
    if(!f) return;
    const r=new FileReader();
    r.onload=()=>{
      try {
        entityTypeConfig = JSON.parse(r.result);
        entityTypeFilters = entityTypeConfig.map(() => false);
        Object.keys(iconCache).forEach(k => delete iconCache[k]);
        Object.keys(tintedIconCache).forEach(k => delete tintedIconCache[k]);
        entityTypeConfig.forEach((c,i)=>{
          if(c.renderType==='icon'&&c.icon){
            const img=new Image(); img.src=c.icon; iconCache[i]=img;
            img.onload = ()=>{
              if(c.tintColor) tintedIconCache[i]=createTintedIcon(img,c.tintColor);
              scheduleDraw();
            };
          }
        });
        buildEntityTypes();
        scheduleDraw();
      } catch(err){
        alert('Invalid JSON: '+err);
      }
    };
    r.readAsText(f);
  });

  /* ============================================================= *
   *  UTILITIES (unchanged)
   * ============================================================= */
  function scheduleDraw(){
    if(!needsRedraw){
      needsRedraw=true;
      requestAnimationFrame(()=>{ needsRedraw=false; drawAll(); });
    }
  }
  function worldToCanvas(x,y){
    const px=(x - worldBounds.minX)/(worldBounds.maxX - worldBounds.minX)*canvas.width;
    const py=(y - worldBounds.minY)/(worldBounds.maxY - worldBounds.minY)*canvas.height;
    return {cx:px, cy:canvas.height-py};
  }
  function resizeCanvas(){
    if(!mapImage) return;
    const rect=canvas.parentElement.getBoundingClientRect();
    canvas.width  = rect.width;
    canvas.height = rect.width*(mapImage.naturalHeight/mapImage.naturalWidth);
    scheduleDraw();
  }
  window.addEventListener('resize',resizeCanvas);

  function heightToColour(h){
    if(h<heightMin) return belowClr;
    if(h>heightMax) return aboveClr;
    const t=(h-heightMin)/(heightMax-heightMin);
    const hue=240*(1-t);
    return `hsl(${hue},100%,50%)`;
  }
  function rebuildHeightLegend(){
    const grad=`linear-gradient(to right,
      ${belowClr} 0%,
      ${heightToColour(heightMin)} 0%,
      ${heightToColour(heightMax)} 100%,
      ${aboveClr} 100%)`;
    heightLegend.innerHTML=''; 
    const bar=document.createElement('div');
    bar.style.cssText='height:18px;background:'+grad+';border:1px solid #555;margin-bottom:4px';
    heightLegend.append(bar);
    const lbl=document.createElement('div');
    lbl.style.cssText='display:flex;justify-content:space-between;font-size:0.75em;color:#aaa';
    lbl.innerHTML=`<span>&lt;${heightMin}</span><span>${heightMin}</span>
                   <span>${heightMax}</span><span>&gt;${heightMax}</span>`;
    heightLegend.append(lbl);
  }

  function buildZipCache(){
    zipSegments=[]; const tmp={};
    entData.forEach(d=>d.ents.forEach(e=>{
      if(e.props.classname==='zipline') tmp[e.props.link_guid]={start:e,end:null};
    }));
    entData.forEach(d=>d.ents.forEach(e=>{
      if(e.props.classname==='zipline_end'&&tmp[e.props.link_guid]) tmp[e.props.link_guid].end=e;
    }));
    Object.values(tmp).forEach(z=>{
      if(!z.start) return;
      const seg=[{x:z.start.x,y:z.start.y}];
      Object.entries(z.start.props).forEach(([k,v])=>{
        const m=k.match(/_zipline_rest_point_(\d+)/);
        if(m){ const [rx,ry]=v.split(/\s+/).map(Number); seg.push({idx:+m[1],x:rx,y:ry}); }
      });
      seg.sort((a,b)=>a.idx-b.idx);
      if(z.end) seg.push({x:z.end.x,y:z.end.y});
      if(seg.length>1) zipSegments.push(seg);
    });
  }

  function buildEntityTypes(){
    entityTypesDiv.innerHTML='';
    entityTypeConfig.forEach((c,i)=>{
      const lbl=document.createElement('label');
      const cb = document.createElement('input');
      cb.type='checkbox';
      cb.onchange=()=>{ entityTypeFilters[i]=cb.checked; scheduleDraw(); };
      lbl.append(cb,' ',c.nickname);
      entityTypesDiv.append(lbl);
    });
  }

  function buildLegend(){
    legendDiv.innerHTML='';
    entData.forEach(item=>{
      const lbl=document.createElement('label');
      const cb = document.createElement('input');
      cb.type='checkbox'; cb.checked=item.enabled;
      cb.onchange=()=>{ item.enabled=cb.checked; scheduleDraw(); };
      const sw=document.createElement('span');
      sw.style.cssText='width:14px;height:14px;display:inline-block;margin-right:8px;'+
                       'border:1px solid #999;background:'+item.color;
      lbl.append(cb,sw,item.fileName);
      legendDiv.append(lbl);
    });
  }

  function buildFilters(){
    filters={}; missingFilters={};
    propertyKeys.forEach(k=>{ filters[k]=new Set(); missingFilters[k]=false });
    entData.forEach(d=>d.ents.forEach(e=>{
      propertyKeys.forEach(k=>{ if(e.props[k]) filters[k].add(e.props[k]); });
    }));
    filtersDiv.innerHTML='';
    propertyKeys.forEach(key=>{
      const fg=document.createElement('div'); fg.className='filter-group';
      fg.append(Object.assign(document.createElement('strong'),{textContent:key}));

      const allCB=document.createElement('input'); allCB.type='checkbox';
      const allLbl=document.createElement('label'); allLbl.append(allCB,' All');
      allCB.onchange=()=>{
        fg.querySelectorAll('input[data-val]').forEach(ch=>{
          ch.checked = allCB.checked;
          ch.checked ? filters[key].add(ch.dataset.val) : filters[key].delete(ch.dataset.val);
        });
        scheduleDraw();
      };
      fg.append(allLbl);

      const missCB=document.createElement('input'); missCB.type='checkbox';
      const missLbl=document.createElement('label'); missLbl.append(missCB,' Missing');
      missCB.onchange=()=>{ missingFilters[key]=missCB.checked; scheduleDraw(); };
      fg.append(missLbl);

      const search=document.createElement('input');
      search.type='text'; search.placeholder=`Search ${key}`;
      search.oninput=()=>{
        const t=search.value.toLowerCase();
        fg.querySelectorAll('label[data-val]').forEach(l=>{
          l.style.display = l.textContent.toLowerCase().includes(t)?'block':'none';
        });
      };
      fg.append(search);

      [...filters[key]].sort().forEach(v=>{
        const lbl=document.createElement('label'); lbl.dataset.val=v;
        const cb=document.createElement('input'); cb.type='checkbox'; cb.dataset.val=v;
        cb.onchange=()=>{ cb.checked?filters[key].add(v):filters[key].delete(v); scheduleDraw(); };
        lbl.append(cb,' ',v);
        fg.append(lbl);
      });

      filtersDiv.append(fg);
    });
  }

  function updateLimits(){
    const min=parseFloat(heightMinInput.value), max=parseFloat(heightMaxInput.value);
    if(!isFinite(min)||!isFinite(max)||min>=max) return;
    heightMin=min; heightMax=max; rebuildHeightLegend(); scheduleDraw();
  }
  heightMinInput.addEventListener('change',updateLimits);
  heightMaxInput.addEventListener('change',updateLimits);
  hideOutCB.addEventListener('change',()=>{ hideOutOfRange=hideOutCB.checked; scheduleDraw(); });

  function entityIsSkipped(e){
    return propertyKeys.some(k=>{
      if(filters[k].size===0 && !missingFilters[k]) return false;
      const v=e.props[k];
      if(v!==undefined&&v!=='') return !filters[k].has(v);
      return !missingFilters[k];
    });
  }

  /* ============================================================= *
   *  DRAW EVERYTHING (with tinted icons)
   * ============================================================= */
  function drawAll(){
    if(!mapImage||!mapDef) return;
    const {posX,posY,scale} = mapDef;
    worldBounds = {
      minX: posX,
      maxX: posX + mapImage.naturalWidth*scale,
      minY: posY - mapImage.naturalHeight*scale,
      maxY: posY
    };

    // reset & base map
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.translate(transform.offsetX,transform.offsetY);
    ctx.scale(transform.scale,transform.scale);
    ctx.drawImage(mapImage,0,0,canvas.width,canvas.height);

    // height‐coloured dots
    entData.forEach(item=>{
      if(!item.enabled) return;
      item.ents.forEach(e=>{
        if(entityIsSkipped(e)) return;
        if(hideOutOfRange&&(e.h<heightMin||e.h>heightMax)) return;
        const {cx,cy}=worldToCanvas(e.x,e.y);
        ctx.fillStyle=heightToColour(e.h);
        ctx.beginPath(); ctx.arc(cx,cy,5/transform.scale,0,2*Math.PI); ctx.fill();
      });
    });

    // ziplines (unchanged)
    const zipIdx = entityTypeConfig.findIndex(c=>c.renderType==='zipline');
    if(zipIdx>-1 && entityTypeFilters[zipIdx]){
      const cfg=entityTypeConfig[zipIdx];
      ctx.strokeStyle=cfg.color||'orange';
      ctx.lineWidth=(cfg.lineWidth||2)/transform.scale;
      zipSegments.forEach(seg=>{
        ctx.beginPath();
        seg.forEach((p,i)=>{
          const {cx,cy}=worldToCanvas(p.x,p.y);
          i?ctx.lineTo(cx,cy):ctx.moveTo(cx,cy);
        });
        ctx.stroke();
      });
    }

    // other types (including icon+tint)
    entityTypeConfig.forEach((c,i)=>{
      if(i===zipIdx||!entityTypeFilters[i]) return;
      entData.forEach(item=>{
        if(!item.enabled) return;
        item.ents.forEach(e=>{
          let pv=e.props[c.field]||'';
          if(c.valueRegex){
            if(!new RegExp(c.valueRegex).test(pv)) return;
          } else if(c.value!==undefined){
            if(pv!==c.value) return;
          }
          const {cx,cy}=worldToCanvas(e.x,e.y);
          const sx = cx*transform.scale + transform.offsetX;
          const sy = cy*transform.scale + transform.offsetY;

          // ── ICON with tint support ─────────────────────────────────
          if(c.renderType==='icon' && iconCache[i] && iconCache[i].complete){
            const sz = c.size||24;
            ctx.setTransform(1,0,0,1,0,0);

            // pick our tinted canvas if we have it
            const src = (c.tintColor && tintedIconCache[i])
                        ? tintedIconCache[i]
                        : iconCache[i];

            ctx.drawImage(src, sx - sz/2, sy - sz/2, sz, sz);

          // ── other renderTypes unchanged ─────────────────────────────
          } else if(c.renderType==='circle'){
            const rW = c.radiusField
                      ? parseFloat(e.props[c.radiusField]||0)
                      : parseFloat(c.radius||0);
            if(!rW) return;
            const basePx = (rW/(worldBounds.maxX-worldBounds.minX))*canvas.width;
            const rpx    = basePx*transform.scale;
            ctx.setTransform(1,0,0,1,0,0);
            ctx.fillStyle   = c.fillColor||'rgba(255,0,0,0.25)';
            ctx.strokeStyle = c.strokeColor||'#ff4444';
            ctx.lineWidth   = (c.strokeWidth||2)/transform.scale;
            ctx.beginPath(); ctx.arc(sx,sy,rpx,0,2*Math.PI);
            ctx.fill(); ctx.stroke();

          } else if(c.renderType==='dot'){
            const or=c.outerRadius||8, ir=c.innerRadius||4;
            ctx.setTransform(1,0,0,1,0,0);
            ctx.fillStyle = c.outerColor||'lime';
            ctx.beginPath(); ctx.arc(sx,sy,or,0,2*Math.PI); ctx.fill();
            if(c.innerColor){
              ctx.fillStyle = c.innerColor;
              ctx.beginPath(); ctx.arc(sx,sy,ir,0,2*Math.PI); ctx.fill();
            }

          } else if(c.renderType==='text'){
            let txt = c.textField
                      ? (e.props[c.textField]||'')
                      : (c.text||'');
            if(!txt) return;
            if(c.regexFind) txt = txt.replace(new RegExp(c.regexFind,'g'),c.regexReplace||'');
            if(c.replaceUnderscores) txt = txt.replace(/_/g,' ');
            if(c.case==='upper') txt=txt.toUpperCase();
            else if(c.case==='lower') txt=txt.toLowerCase();
            else if(c.case==='title') txt=txt.replace(/\w\S*/g,w=>w[0].toUpperCase()+w.slice(1));

            ctx.setTransform(1,0,0,1,0,0);
            const base = c.fontSize||14;
            const fs   = c.scaleWithZoom?base*transform.scale:base;
            ctx.font         = `${fs}px ${c.fontFamily||'Arial'}`;
            ctx.fillStyle    = c.textColor||'#fff';
            ctx.textAlign    = c.textAlign||'center';
            ctx.textBaseline = c.textBaseline||'middle';
            ctx.fillText(txt, sx+(c.offsetX||0), sy+(c.offsetY||0));
          }
        });
      });
    });
  }

  /* ============================================================= *
   *  TOOLTIP, PAN & ZOOM (unchanged)
   * ============================================================= */
  canvas.addEventListener('mousemove',e=>{
    const mx=e.offsetX, my=e.offsetY;
    const cX=(mx-transform.offsetX)/transform.scale;
    const cY=(my-transform.offsetY)/transform.scale;
    let found=null, r=5/transform.scale;

    outer: for(const item of entData){
      if(!item.enabled) continue;
      for(const ent of item.ents){
        if(entityIsSkipped(ent)) continue;
        if(hideOutOfRange&&(ent.h<heightMin||ent.h>heightMax)) continue;
        const {cx,cy}=worldToCanvas(ent.x,ent.y);
        if((cX-cx)**2+(cY-cy)**2<r*r){
          found=ent; break outer;
        }
      }
    }

    if(found){
      tooltip.style.display='block';
      tooltip.style.left = (mx+10)+'px';
      tooltip.style.top  = (my+10)+'px';
      tooltip.innerHTML  = Object.entries(found.props)
        .map(([k,v])=>`<strong>${k}</strong>: ${typeof v==='object'?JSON.stringify(v):v}`)
        .join('<br>');
    } else {
      tooltip.style.display='none';
    }
  });

  ['wheel','mousedown','mousemove','mouseup','mouseleave'].forEach(evt=>{
    canvas.addEventListener(evt,e=>{
      if(evt==='wheel'){
        e.preventDefault();
        const f = e.deltaY<0?1.1:0.9;
        const ns=transform.scale*f;
        transform.offsetX = e.offsetX-(e.offsetX-transform.offsetX)*(ns/transform.scale);
        transform.offsetY = e.offsetY-(e.offsetY-transform.offsetY)*(ns/transform.scale);
        transform.scale = ns; scheduleDraw();
      } else if(evt==='mousedown'){
        isDragging=true;
        dragStart.x=e.clientX-transform.offsetX;
        dragStart.y=e.clientY-transform.offsetY;
        canvas.style.cursor='grabbing';
      } else if(evt==='mousemove'&&isDragging){
        transform.offsetX=e.clientX-dragStart.x;
        transform.offsetY=e.clientY-dragStart.y;
        scheduleDraw();
      } else if(evt==='mouseup'||evt==='mouseleave'){
        isDragging=false; canvas.style.cursor='grab';
      }
    });
  });

  /* ============================================================= *
   *  KICK-OFF
   * ============================================================= */
  loadDefaultList();
  loadDefaultEntityTypes();
  </script>
</body>
</html>
